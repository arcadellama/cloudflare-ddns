#!/usr/bin/env sh
#
# MIT License
# 
# Copyright (c) 2023 Justin Teague
# 
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal 
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
# 
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
# 
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

## PROGRAM CONSANTS ##
PRGNAM=$(basename "$0")
VERSION='0.0.42'

## CONFIGURATION LOCATIONS ##
CONFFILE="${CONFFILE:-}"
CONFIG_FILE_LOCATIONS="
$PWD/$PRGNAM.conf
${XDG_CONFIG_HOME:=$HOME/.config}/$PRGNAM.conf
$HOME/$PRGNAM.conf
$HOME/.$PRGNAM.conf"

## CONFIGURATION VARIABLES ##
CF_API_KEY="${CF_API_KEY:-}"
CF_API_URL="${CF_API_URL:-https://api.cloudflare.com/client/v4}"
CF_API_ZONE="${CF_API_ZONE:-}"
CF_DOMAINS="${CF_DOMAINS:-}"
CF_ZONE_ID="${CF_ZONE_ID:-}"
PUBLIC_IP_ADDRESS="${PUBLIC_IP_ADDRESS:-}"
PUBLIC_API_URL="
https://ipv4.icanhazip.com
https://ifconfig.me/ip
https://api.ipify.org
https://api.seeip.org"
VERBOSE="${VERBOSE:-0}"

## DEPENDENCIES ##
CURL_BIN="${CURL_BIN:-$(command -v curl)}" || die "curl not found in PATH"
JQ_BIN="${JQ_BIN:-$(command -v jq)}" || die "jq not found in PATH"

## FUNCTIONS ##
usage() {
  if [ "$VERBOSE" -gt -1 ]; then
  cat << EOF
$PRGNAM -- Version: $VERSION

USAGE
$PRGNAM [-hqvV] [-F config] [-f address] [-k key] [-z zone] domains

OPTIONS
    -F  conffile    Read configuration options from conffile
                    (default: \$HOME/.config/$PRGNAM.conf)   
    -h              Show this screen
    -f  address     Force public IP address to update      
    -k  api key     Cloudflare API Key
    -q              Quiet mode
    -v              Verbose mode
    -V              Show version
    -z              Cloudflare DNS Zone

CONFIGURATION VARIABLES

  CF_API_KEY        Cloudflare API Key for Zone
                    (required)
  CF_API_URL        Cloudflare API URL
  CF_DOMAINS        Domain(s) to update
  PUBLIC_API_URL    API to get public IP address
  VERBOSE           Verbosity: 0 or 1
  CF_API_ZONE       Pre-defined Cloudflare DNS Zone

CONFIGURATION LOCATIONS
  ./$PRGNAM.conf
  \$XDG_CONFIG_HOME/$PRGNAM.conf
  \$HOME/.config/$PRGNAM.conf
  \$HOME/$PRGNAM.conf
  \$HOME/.$PRGNAM.conf
  /usr/local/etc/$PRGNAM.conf
  /usr/etc/$PRGNAM.conf
  
EOF
  fi
  exit "${1:-0}" 
}

out() {
  printf %s\\n "$*"
}

log() {
  if [ "$VERBOSE" -gt -1 ]; then
    out "$*"
  fi
}

inf() {
  if [ "$VERBOSE" -gt 0 ]; then
    >&2 out "$*"
  fi
}

err() {
  if [ "$VERBOSE" -gt -1 ]; then
    >&2 out "$*"
  fi
}

errinf() {
  if [ "$VERBOSE" -gt 0 ]; then
    >&2 out "$*"
  fi
}

die() {
  err "$*" ; exit "${1:-1}"
}

get_config_file() {
  for _file in $CONFIG_FILE_LOCATIONS; do
    if [ -r "$_file" ]; then
      out "$_file"
      return
    fi
  done
  return 1
}

http_req(){
  _response=$(mktemp 2>&1) || die "$_response"
  if ! _ret=$("$CURL_BIN" -sS \
    -o "$_response" \
    -w '%{http_code}' \
    "$@" 2>&1); then
    out "$_ret"
    return 1
  fi

  if [ "$_ret" -ge 400 ]; then
    out "HTTP Error Code: $_ret"
    out "$(cat "$_response")"
    return 1
  fi

  cat "$_response"
  rm -rf "$_response"
}

parse_conf() {
  # Accepts: CONFFILE
  if [ ! -r "$1" ]; then err "$1 not a readable file"; return 1; fi
  while read -r _line; do
    case "$_line" in
      \#*) continue ;;
             CF_DOMAINS=*) CF_DOMAINS=${CF_DOMAINS:=${_line#*=}} ;;
             CF_API_KEY=*) CF_API_KEY=${CF_API_KEY:=${_line#*=}} ;;
             CF_API_URL=*) CF_API_URL=${CF_API_URL:=${_line#*=}} ;;
            CF_API_ZONE=*) CF_API_ZONE=${CF_API_ZONE:=${_line#*=}} ;;
         PUBLIC_API_URL=*) PUBLIC_API_URL=${PUBLIC_API_URL:=${_line#*=}} ;;
      PUBLIC_IP_ADDRESS=*) PUBLIC_IP_ADDRESS=${PUBLIC_IP_ADDRESS:=${_line#*=}} ;;
    esac
  done < "$1"
}

parse_json() {
  "$JQ_BIN" -r "$@"
}

parse_opts() {
  while getopts :hqvV _opts; do
    case "$_opts" in
      h)
        usage
        ;;

      q)
        if [ "$VERBOSE" -eq 1 ]; then
          err "Cannot choose both 'q' and 'v'"
          usage 1
        fi
        VERBOSE=-1
        ;;

      v)  
        if [ "$VERBOSE" -eq -1 ]; then
          VERBOSE=1
          err "Cannot choose both 'v' and 'q'"
          usage 1
        fi
        VERBOSE=1
        ;;
      V)
        out "$PRGNAM -- Version: $VERSION"
        exit
        ;;

      *)
        err "Invalid option: $_opts"
        usage 1
        ;;
    esac
  done
}

main() {
  _commands=""
  # Parse args
  while [ "$#" -gt 0 ]; do
    case "$1" in
      help | usage | check | show | update)
        _commands="${_commands:-} $1"
        shift ;;
      -f) PUBLIC_IP_ADDRESS="$2"; shift 2 ;;
      -F) CONFFILE="$2"; shift 2 ;;
      -k) CF_API_KEY="$2"; shift 2 ;;
      -z) CF_API_ZONE="$2"; shift 2 ;;
      -*) parse_opts "$1"; shift ;;
       *) CF_DOMAINS="${CF_DOMAINS:-} $1"; shift ;;
     esac
  done

  # Check for configuration file
  if [ -n "$CONFFILE" ]; then
    if [ ! -r "$CONFFILE" ]; then
      die "Error: $CONFFILE not found."
    fi
  fi
  
  # Check for configuration if API not specified
  if [ -z "$CONFFILE" ]; then
    if ! CONFFILE=$(get_config_file); then
      CONFFILE=""
    fi
  fi

  # Parse configuration
  if [ -n "$CONFFILE" ]; then
    parse_conf "$CONFFILE"
  fi
  
  # Exit if no zone defined
  if [ -z "$CF_API_ZONE" ]; then
    err "No zone set."
    usage 1
  fi
  
  # Exit if no domains given
  if [ -z "$CF_DOMAINS" ]; then
    err "No domains specified."
    usage 1
  fi

  # Check API key
  if [ -z "$CF_API_KEY" ]; then
    err "Cloudflare API Key not defined."
    usage 1
  fi
  
  # Get public ip
  if [ -z "$PUBLIC_IP_ADDRESS" ]; then
    for _public_api in $PUBLIC_API_URL; do
      if PUBLIC_IP_ADDRESS=$(http_req \
        --request GET \
        --url "$_public_api"); then
        inf "Public IP $PUBLIC_IP_ADDRESS found via $_public_api"
        break
      else
        err "Unable to get public ip address from $_public_api"
        errinf "$PUBLIC_IP"
        PUBLIC_IP_ADDRESS=""
      fi
    done
  fi

  if [ -z "$PUBLIC_IP_ADDRESS" ]; then
    die "Unable to get public ip address."
  fi

  # Verify API Key
  _verify_api=""
  if ! _verify_api=$(http_req \
    --request GET \
    --url "$CF_API_URL/user/tokens/verify" \
    --header "Content-Type: application/json" \
    --header "Authorization: Bearer $CF_API_KEY"); then
    err "Cloudflare API not verified."
    errinf "$_verify_api"
    exit 1
  fi

  # Get Cloudflare Zones
  _cf_zones=""
  if ! _cf_zones=$(http_req \
    --request GET \
    --url "$CF_API_URL/zones" \
    --header "Content-Type: application/json" \
    --header "Authorization: Bearer $CF_API_KEY"); then
    err "Unable to get DNS Zones"
    errinf "$_cf_zones"
    exit 1
  fi

  # Get Zone ID
  if ! CF_ZONE_ID=$(out "$_cf_zones" | \
    parse_json '.result[] | select(.name == "'"$CF_API_ZONE"'") | .id'); then
    err "Error parsing Zone JSON"
    errinf "$_cf_zones"
    exit 1
  elif [ "$CF_ZONE_ID" = "null" ]; then
    err "Error: CF_ZONE_ID not found for $CF_API_ZONE."
    errinf "$_cf_zones"
    exit 1
  fi

  if [ -z "$CF_ZONE_ID" ]; then
    die "Unable to get Zone ID for $CF_API_ZONE"
  fi

  # Check for domains in Zone ID and update records as needed
  _retval=0
  _domain=""
  for _domain in $CF_DOMAINS; do
    # Get DNS record JSON
    _dns_records=""
    if ! _dns_records=$(http_req \
      --request GET \
      --url "$CF_API_URL/zones/$CF_ZONE_ID/dns_records" \
      --header "Content-Type: application/json" \
      --header "Authorization: Bearer $CF_API_KEY"); then
      err "Unable to get DNS records"
      errinf "$_dns_records"
      _retval=$((_retval+1))
      continue
    fi

    # Parse DNS Records for domain ID
    _dns_id=""
    if ! _dns_id=$(out "$_dns_records" | \
      parse_json '.result[] | select(.name == "'"$_domain"'") | .id'); then
      err "Error parsing DNS JSON."
      errinf "$_dns_id"
      _retval=$((_retval+1))
      continue
    elif [ "$_dns_id" = "null" ]; then
      err "Error getting DNS ID from DNS Records JSON."
      errinf "$_dns_records"
      _retval=$((_retval+1))
      continue
    fi

    if [ -z "$_dns_id" ]; then
      err "Unable to get DNS ID for $_domain"
      _retval=$((_retval+1))
      continue
    fi

    inf "DNS ID for $_domain: $_dns_id"

    # Parse DNS records for domain IP address
    _dns_ip=""
    if ! _dns_ip=$(out "$_dns_records" | \
      parse_json '.result[] | select(.id == "'"$_dns_id"'") | .content'); then
      err "Error getting IP address from DNS JSON."
      errinfo "$_dns_records"
      _retval=$((_retval+1))
      continue
    elif [ "$_dns_ip" = "null" ]; then
      err "Error getting DNS IP address from DNS Records JSON."
      errinf "$_dns_records"
      _retval=$((_retval+1))
      continue
    fi

    if [ -z "$_dns_ip" ]; then
      err "Unable to get DNS IP Address for $_domain"
      _retval=$((_retval+1))
      continue
    fi

    inf "DNS IP for $_domain: $_dns_ip"

    # Check dns ip with public ip
    if [ "$PUBLIC_IP_ADDRESS" = "$_dns_ip" ]; then
      inf "$_domain is already set to $PUBLIC_IP_ADDRESS."
      continue
    fi

    # Update dns ip
    _update_dns_ip=""
    if ! _update_dns_ip=$(http_req \
      --request PATCH \
      --url "$CF_API_URL/zones/$CF_ZONE_ID/dns_records/$_dns_id" \
      --header "Content-Type: application/json" \
      --header "Authorization: Bearer $CF_API_KEY" \
      --data '{"content": "'"$PUBLIC_IP_ADDRESS"'"}'); then
      err "Unable to patch $_domain with public ip $PUBLIC_IP_ADDRESS."
      errinf "$_update_dns_ip"
      _retval=$((_retval+1))
      continue
    fi

    log "$_domain updated from $_dns_ip to $PUBLIC_IP_ADDRESS"

  done
  return "$_retval"
}

main "$@"
