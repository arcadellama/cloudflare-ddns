#!/usr/bin/env sh
#
# MIT License
# 
# Copyright (c) 2023 Justin Teague
# 
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal 
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
# 
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
# 
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

LC_ALL=C

## PROGRAM CONSANTS ##
PRGNAM='ddnsh'
VERSION='0.0.42'

## CONFIGURATION LOCATIONS ##
CONFFILE="${CONFFILE:-}"
CONFIG_FILE_LOCATIONS="
$PWD/$PRGNAM.conf
$PWD/.$PRGNAM.conf
$HOME/$PRGNAM.conf
$HOME/.$PRGNAM.conf
$HOME/.config/$PRGNAM.conf
$HOEM/.local/etc/$PRGNAM.conf
/usr/local/etc/$PRGNAM.conf
/etc/$PRGNAM.conf"

## CONFIGURATION VARIABLES ##
CF_API_KEY="${CF_API_KEY:-}"
CF_API_URL="${CF_API_URL:-https://api.cloudflare.com/client/v4}"
CF_API_ZONE="${CF_API_ZONE:-}"
CF_DOMAINS="${CF_DOMAINS:-}"
PUBLIC_IP_ADDRESS="${PUBLIC_IP_ADDRESS:-}"
PUBLIC_IP_V4="${PUBLIC_IP_V4:-}"
PUBLIC_IP_V6="${PUBLIC_IP_V6:-}"
PUBLIC_API_URL="${PUBLIC_API_URL:-}"
PUBLIC_IP_LIST_V4="
https://ipv4.seeip.org
https://api4.ipify.org
https://ipv4.icanhazip.com"
PUBLIC_IP_LIST_V6="
https://ipv6.seeip.org
https://api6.ipify.org
https://ipv6.icanhazip.com"
VERBOSE="${VERBOSE:-0}"

## DEPENDENCIES ##
CURL_BIN="${CURL_BIN:-$(command -v curl)}" || die "curl not found in PATH"
JQ_BIN="${JQ_BIN:-$(command -v jq)}" || die "jq not found in PATH"

## FUNCTIONS ##
usage() {
  if [ "$VERBOSE" -gt -1 ]; then
  cat << EOF
$PRGNAM -- Version: $VERSION

USAGE
$PRGNAM [-46hqvV] [-F config] [-f address] [-k key] [-z zone] COMMAND domains

COMMANDS
    check           Check if domain(s) match public IP address
    help            This message
    update          Update domain(s) to match public IP address

OPTIONS
    -4              IPv4 Public Address (default)
    -6              IPv6 Public Address
                    (if 4 & 6 will attempt v6 and fallback on v4)
    -F  conffile    Read configuration options from conffile
                    (default: \$HOME/.config/$PRGNAM.conf)   
    -h              Show this screen
    -f  address     Force public IP address to update      
    -k  api key     Cloudflare API Key
    -q              Quiet mode
    -v              Verbose mode
    -V              Show version
    -z              Cloudflare DNS Zone

CONFIGURATION VARIABLES

  CF_API_KEY        Cloudflare API Key for Zone
  CF_API_ZONE       Pre-defined Cloudflare DNS Zone
  CF_DOMAINS        Domain(s) to update
  PUBLIC_API_URL    API to get public IP address
  VERBOSE           Verbosity: 0 or 1

CONFIGURATION LOCATIONS
  ./$PRGNAM.conf
  \$HOME/$PRGNAM.conf
  \$HOME/.$PRGNAM.conf
  \$HOME/.config/$PRGNAM.conf
  \$HOME/.local/etc/$PRGNAM.conf
  /usr/local/etc/$PRGNAM.conf
  /usr/etc/$PRGNAM.conf
  
EOF
  fi
  exit "${1:-0}" 
}

out() {
  printf %s\\n "$*"
}

log() {
  if [ "$VERBOSE" -gt -1 ]; then
    out "$*"
  fi
}

inf() {
  if [ "$VERBOSE" -gt 0 ]; then
    >&2 out "$*"
  fi
}

err() {
  if [ "$VERBOSE" -gt -1 ]; then
    >&2 out "ERROR: $*"
  fi
}

errinf() {
  if [ "$VERBOSE" -gt 0 ]; then
    >&2 out "ERROR: $*"
  fi
}

die() {
  err "$*" ; exit 1
}

get_cf_zone_json() {
  # Returns: Cloudflare Zones JSON
  if ! _zone_res=$(http_req \
    --request GET \
    --url "$CF_API_URL/zones" \
    --header "Content-Type: application/json" \
    --header "Authorization: Bearer $CF_API_KEY"); then
    out "$_zone_res"
    return 1
  fi
  out "$_zone_res"
}

get_cf_zone_id() {
  # Accepts: Zone JSON
  # Returns: Zone ID matching CF_API_ZONE
  if ! _zone_id=$(out "$1" | \
    parse_json \
    '.result[] | select(.name == "'"$CF_API_ZONE"'") | .id' 2>&1); then
    out "$_zone_id"
    return 1
  elif [ "$_zone_id" = "null" ]; then
    out "$_zone_id"
    return 1
  fi
  out "$_zone_id"
}

get_config_file() {
  for _file in $CONFIG_FILE_LOCATIONS; do
    if [ -r "$_file" ]; then
      out "$_file"
      return
    fi
  done
  return 1
}

get_public_ip() {
  # Returns: Public IP Address
  for _public_api in $PUBLIC_API_URL; do
    _addr=""
    if _addr=$(http_req \
      --request GET \
      --url "$_public_api"); then
      inf "Public IP $_addr found at $_public_api"
      out "$_addr"
      return 
    else
      errinf "Unable to get public ip address from $_public_api"
    fi
  done
  out "Failed to get public IP address. Check connection."
  return 1
}

http_req(){
  _response=$(mktemp 2>&1) || die "$_response"
  if ! _ret=$("$CURL_BIN" -sS \
    -o "$_response" \
    -w '%{http_code}' \
    "$@" 2>&1); then
    out "$_ret"
    return 1
  fi

  if [ "$_ret" -ge 400 ]; then
    out "HTTP Error Code: $_ret"
    out "$(cat "$_response")"
    return 1
  fi

  cat "$_response"
  rm -rf "$_response"
}

parse_conf() {
  # Accepts: CONFFILE
  if [ ! -r "$1" ]; then err "$1 not a readable file"; return 1; fi
  while read -r _line; do
    case "$_line" in
      \#*) continue ;;
             CF_DOMAINS=*) CF_DOMAINS=${CF_DOMAINS:=${_line#*=}}          ;;
             CF_API_KEY=*) CF_API_KEY=${CF_API_KEY:=${_line#*=}}          ;;
             CF_API_URL=*) CF_API_URL=${CF_API_URL:=${_line#*=}}          ;;
            CF_API_ZONE=*) CF_API_ZONE=${CF_API_ZONE:=${_line#*=}}        ;;
         PUBLIC_API_URL=*) PUBLIC_API_URL=${PUBLIC_API_URL:=${_line#*=}}  ;;
    esac
  done < "$1"
}

parse_json() {
  "$JQ_BIN" -r "$@"
}

cmd_check() {
  cmd_update --check-only
}

cmd_update() {
  _check_only=""
  case "$1" in --check-only) _check_only=1 ;; esac
  # Get Zone JSON
  if ! _cf_zone_json=$(get_cf_zone_json); then
    err "API Error getting Cloudflare Zones"
    errinf "$_cf_zone_json"
    return 1
  fi

  # Get Zone ID matching CF_API_ZONE
  if ! CF_ZONE_ID="$(get_cf_zone_id "$_cf_zone_json")"; then
    err "No matching Zone ID for $CF_API_ZONE"
    errinf "$CF_ZONE_ID"
    return 1
  fi

  if [ -z "$CF_ZONE_ID" ]; then
    die "Unable to get Zone ID for $CF_API_ZONE"
  fi

  # Check for domains in Zone ID and update records as needed
  _retval=0
  _domain=""
  for _domain in $CF_DOMAINS; do
    # Get DNS record JSON
    _dns_records=""
    if ! _dns_records=$(http_req \
      --request GET \
      --url "$CF_API_URL/zones/$CF_ZONE_ID/dns_records" \
      --header "Content-Type: application/json" \
      --header "Authorization: Bearer $CF_API_KEY"); then
      err "Unable to get DNS records"
      errinf "$_dns_records"
      _retval=$((_retval+1))
      continue
    fi

    # Parse DNS Records for domain ID
    _dns_id=""
    if ! _dns_id=$(out "$_dns_records" | \
      parse_json \
      '.result[] | select(.name == "'"$_domain"'") | .id' 2>&1); then
      err "Cannot parse DNS JSON."
      errinf "$_dns_id"
      _retval=$((_retval+1))
      continue
    elif [ "$_dns_id" = "null" ]; then
      err "Cannot get DNS ID from DNS Records JSON."
      errinf "$_dns_records"
      _retval=$((_retval+1))
      continue
    fi

    if [ -z "$_dns_id" ]; then
      err "Cannot get DNS ID for $_domain"
      _retval=$((_retval+1))
      continue
    fi

    inf "DNS ID for $_domain: $_dns_id"

    # Parse DNS records for domain IP address
    _dns_ip=""
    if ! _dns_ip=$(out "$_dns_records" | \
      parse_json \
      '.result[] | select(.id == "'"$_dns_id"'") | .content') 2>&1; then
      err "Cannot get IP address from DNS JSON."
      errinf "$_dns_records"
      _retval=$((_retval+1))
      continue
    elif [ "$_dns_ip" = "null" ]; then
      err "Cannot get DNS IP address from DNS Records JSON."
      errinf "$_dns_records"
      _retval=$((_retval+1))
      continue
    fi

    if [ -z "$_dns_ip" ]; then
      err "Unable to get DNS IP Address for $_domain"
      _retval=$((_retval+1))
      continue
    fi

    inf "DNS IP for $_domain: $_dns_ip"

    # Check dns ip with public ip
    if [ "$PUBLIC_IP_ADDRESS" = "$_dns_ip" ]; then

      if [ -n "$_check_only" ]; then
        log "$_domain is already set to $PUBLIC_IP_ADDRESS."
      else
        inf "$_domain is already set to $PUBLIC_IP_ADDRESS."
      fi
      continue

    elif [ -n "$_check_only" ]; then
      log "$_domain ($_dns_ip) is not set to public ip ($PUBLIC_IP_ADDRESS)"
      continue
    fi

    # Update dns ip
    _update_dns_ip=""
    if ! _update_dns_ip=$(http_req \
      --request PATCH \
      --url "$CF_API_URL/zones/$CF_ZONE_ID/dns_records/$_dns_id" \
      --header "Content-Type: application/json" \
      --header "Authorization: Bearer $CF_API_KEY" \
      --data '{"content": "'"$PUBLIC_IP_ADDRESS"'"}'); then
      err "Unable to patch $_domain with public ip $PUBLIC_IP_ADDRESS."
      errinf "$_update_dns_ip"
      _retval=$((_retval+1))
      continue
    fi

    log "$_domain updated from $_dns_ip to $PUBLIC_IP_ADDRESS"

  done
  return "$_retval"
}

parse_opts() {
  while getopts :46hqvV _opts; do
    case "$_opts" in
      4)  PUBLIC_IP_V4=1 ;;
      6)  PUBLIC_IP_V6=1 ;;
      h)  usage ;;
      q)  if [ "$VERBOSE" -eq 1 ]; then
            err "Cannot choose both 'q' and 'v'"
            usage 1
          fi
          VERBOSE=-1 ;;
      v)  if [ "$VERBOSE" -eq -1 ]; then
            VERBOSE=1
            err "Cannot choose both 'v' and 'q'"
            usage 1
          fi
          VERBOSE=1 ;;
      V)  out "$PRGNAM -- Version: $VERSION" ; exit ;;
      *)  err "Invalid option: $_opts" ; usage 1 ;;
    esac
  done
}

main() {
  _commands=""
  # Parse args
  while [ "$#" -gt 0 ]; do
    case "$1" in
      help) usage 0 ;;
      check | update) _commands="${_commands:-} $1" ; shift ;;
      -f) PUBLIC_IP_ADDRESS="$2"; shift 2 ;;
      -F) CONFFILE="$2"; shift 2 ;;
      -k) CF_API_KEY="$2"; shift 2 ;;
      -z) CF_API_ZONE="$2"; shift 2 ;;
      -*) parse_opts "$1"; shift ;;
       *) CF_DOMAINS="${CF_DOMAINS:-} $1"; shift ;;
     esac
  done

  # Check for configuration file
  if [ -n "$CONFFILE" ]; then
    if [ ! -r "$CONFFILE" ]; then
      die "$CONFFILE not found."
    fi
  fi
  
  # Check for configuration if API not specified
  if [ -z "$CONFFILE" ]; then
    if ! CONFFILE=$(get_config_file); then
      CONFFILE=""
    fi
  fi

  # Parse configuration
  if [ -n "$CONFFILE" ]; then
    parse_conf "$CONFFILE"
  fi

  # Exit if no zone or domains defined
  if [ -z "$CF_API_ZONE" ] && [ -z "$CF_DOMAINS" ]; then
    err "No zone or domain specified."
    usage 1
  fi
  
  # Assign zone to first domain if unset
  if [ -z "$CF_API_ZONE" ]; then
    for _first_domain in $CF_DOMAINS; do
      inf "No zone specified, setting to $_first_domain..."
      CF_API_ZONE="$_first_domain"
      break
    done
  fi

  if [ -z "$CF_DOMAINS" ]; then
    inf "No domain(s) specified, setting to $CF_API_ZONE"
    CF_DOMAINS="$CF_API_ZONE"
  fi

  # Check API key exists
  if [ -z "$CF_API_KEY" ]; then
    err "Cloudflare API Key not defined."
    usage 1
  fi
  
  # Verify Cloudflare API Key
  _verify_api=""
  if ! _verify_api=$(http_req \
    --request GET \
    --url "$CF_API_URL/user/tokens/verify" \
    --header "Content-Type: application/json" \
    --header "Authorization: Bearer $CF_API_KEY"); then
    err "Cloudflare API not verified."
    errinf "$_verify_api"
    exit 1
  fi

  # Assemble public IP address list
  if [ -z "$PUBLIC_API_URL" ]; then
    if [ -z "$PUBLIC_IP_V6" ] && [ -z "$PUBLIC_IP_V4" ]; then
      PUBLIC_API_URL="$PUBLIC_IP_LIST_V4"
    else
      [ -n "$PUBLIC_IP_V6" ] && \
        PUBLIC_API_URL="$PUBLIC_IP_LIST_V6"
      [ -n "$PUBLIC_IP_V4" ] && \
        PUBLIC_API_URL="${PUBLIC_API_URL} $PUBLIC_IP_LIST_V4"
    fi
  fi

  # Get public IP address
  if [ -z "$PUBLIC_IP_ADDRESS" ]; then
    if ! PUBLIC_IP_ADDRESS="$(get_public_ip)"; then
      err "Cannot get public IP address."
      errinf "$PUBLIC_IP_ADDRESS"
      return 1
    fi
  fi
  
  # Process commands
  if [ -n "$_commands" ]; then
    for _cmd in $_commands; do
      cmd_"${_cmd}"
    done
  else
    # default command
    cmd_check
  fi
}

main "$@"
