#!/usr/bin/env sh
#
# MIT License
# 
# Copyright (c) 2023 Justin Teague
# 
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal 
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
# 
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
# 
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

## PROGRAM CONSANTS ##
PRGNAM=$(basename "$0")
VERSION='0.0.42'

## CONFIGURATION LOCATIONS ##
CONFFILE="${CONFFILE:-}"
CONFIG_FILE_LOCATIONS="
$PWD/$PRGNAM.conf
${XDG_CONFIG_HOME:=$HOME/.config}/$PRGNAM.conf
$HOME/$PRGNAM.conf
$HOME/.$PRGNAM.conf"

## CONFIGURATION VARIABLES ##
CF_API_KEY="${CF_API_KEY:-}"
CF_API_URL="https://api.cloudflare.com/client/v4"
DOMAINS="${DOMAINS:-}"
PUBLIC_API_URL="https://ifconfig.me/ip
https://api.ipify.org
https://api.seeip.org"
VERBOSE="${VERBOSE:-0}"

## DEPENDENCIES ##
CURL_BIN='curl'
JQ_BIN='jq'

## FUNCTIONS ##
usage() {
  cat << EOF
$PRGNAM -- Version: $VERSION
usage: $PRGNAM [-hqvV] [-F config] [-i address] domains

Options:

  -F  conffile    Read configuration options from conffile
                  (default: \$HOME/.config/$PRGNAM.conf)   
  -h              Show this screen.
  -i  address     Manually specify the IP address to update.        
                  (Overrides automatic IP API URL)
  -q              Quiet mode.
  -v              Verbose mode.
  -V              Show version.



Configuration Variables:

  CF_API_KEY      Cloudflare API Key for Zone
                  (required)
  CF_API_URL      Cloudflare API URL
                  (optional)
  CURL_BIN        Path to curl
                  (optional)
  DOMAINS         Domains to update
                  (optional)
  JQ_BIN          Path to jq
                  (optional)
  PUBLIC_API_URL  API to get public IP address
                  (optional)
  VERBOSE         Verbosity: 0 or 1
                  (optional)

Configuration Locations (in order of priority):
  ./$PRGNAM.conf
  \$XDG_CONFIG_HOME/$PRGNAM.conf
  \$HOME/.config/$PRGNAM.conf
  \$HOME/$PRGNAM.conf
  \$HOME/.$PRGNAM.conf
  
EOF
  exit "${1:-0}" 
}

out() {
  printf %s\\n "$*"
}

inf() {
  if [ "$VERBOSE" -gt 0 ]; then
    out "$*"
  fi
}

err() {
  if [ "$VERBOSE" -gt -1 ]; then
    >&2 out "$*"
  fi
}

errinf() {
  if [ "$VERBOSE" -gt 0 ]; then
    >&2 out "$*"
  fi
}

die() {
  err "$*" ; exit "${1:-1}"
}

get_config() {
  for _file in $CONFIG_FILE_LOCATIONS; do
    if [ -r "$_file" ]; then
      out "$_file"
      return
    fi
  done
  return 1
}

http_req(){
  _response=$(mktemp 2>&1) || die "$_response"
  if ! _ret=$("$CURL_BIN" -sS \
    -o "$_response" \
    -w '%{http_code}' \
    "$@" 2>&1); then
    out "$_ret"
    return 1
  fi

  if [ "$_ret" -ge 400 ]; then
    out "HTTP Error Code: $_ret"
    out "$(cat "$_response")"
    return 1
  fi

  cat "$_response"
  rm -rf "$_response"
}

parse_json() {
  "$JQ_BIN" -r "$@"
}

parse_opts() {
  _opts="$(printf %s\\n "${1#-}" | sed 's/./ &/g')"
  for _arg in $_opts; do
    case "$_arg" in
      q)
        if [ "$VERBOSE" -eq 1 ]; then
          err "Cannot choose both 'q' and 'v'"
          usage 1
        fi
        VERBOSE=-1
        ;;

      v)  
        if [ "$VERBOSE" -eq -1 ]; then
          VERBOSE=1
          err "Cannot choose both 'v' and 'q'"
          usage 1
        fi
        VERBOSE=1
        ;;
      V)
        out "$PRGNAM -- $VERSION"
        exit
        ;;

      h)
        usage
        ;;

      *)
        err "Invalid option: $_arg"
        usage 1
        ;;
    esac
  done
}

main() {
  verify=""
  zones=""
  public_ip=""

  # Parse args
  while [ "$#" -gt 0 ]; do
    case "$1" in
      -i) public_ip="$2" ; shift 2 ;;
      -F) if [ -r "$2" ]; then CONFFILE="$2"; shift 2; else usage 1; fi ;;
      -*) parse_opts "$1" ; shift ;;
       *) DOMAINS="${DOMAINS:-} $1"; shift ;;
     esac
   done

  # Exit if no domains given
  if [ -z "$DOMAINS" ]; then err "No domains specified."; usage 1; fi

  # Check for configuration
  if [ -z "$CONFFILE" ]; then
    if ! CONFFILE=$(get_config); then
      die "No configuration file found."
    fi
  fi

  # Parse configuration
  while read -r _line; do
    case "$_line" in
      \#*) continue ;;
             DOMAINS=*) DOMAINS=${DOMAINS:=${_line#*=}}               ;;
          CF_API_KEY=*) CF_API_KEY=${CF_API_KEY:=${_line#*=}}         ;;
          CF_API_URL=*) CF_API_URL=${CF_API_URL:=${_line#*=}}         ;;
            CURL_BIN=*) CURL_BIN=${CURL_BIN:=${_line#*=}}             ;;
              JQ_BIN=*) JQ_BIN=${JQ_BIN:=${_line#*=}}                 ;;
      PUBLIC_API_URL=*) PUBLIC_API_URL=${PUBLIC_API_URL:=${_line#*=}} ;;
    esac
  done < "$CONFFILE"

  # Check API key
  if [ -z "$CF_API_KEY" ]; then
    die "Cloudflare API Key not defined."
  fi

  # Check dependencies
  if ! command -v "$CURL_BIN" >/dev/null 2>&1; then
    die "$CURL_BIN not found in PATH."
  elif ! command -v "$JQ_BIN" >/dev/null 2>&1; then
    die "$JQ_BIN not found in PATH."
  fi
  
  # Get public ip
  if [ -z "$public_ip" ]; then
    for _public_api in $PUBLIC_API_URL; do
      if public_ip=$(http_req \
        --request GET \
        --url "$_public_api"); then
        inf "Public IP $public_ip found via $_public_api"
        break
      else
        err "Unable to get public ip address from $_public_api"
        inf "$public_ip"
        public_ip=""
      fi
    done
  fi

  if [ -z "$public_ip" ]; then
    die "Unable to get public ip address."
  fi

  # Verify API Key
  if ! verify=$(http_req \
    --request GET \
    --url "$CF_API_URL/user/tokens/verify" \
    --header "Content-Type: application/json" \
    --header "Authorization: Bearer $CF_API_KEY"); then
    err "Cloudflare API not verified."
    errinf "$verify"
    exit 1
  fi

  # Get Cloudflare Zones
  if ! zones=$(http_req \
    --request GET \
    --url "$CF_API_URL/zones" \
    --header "Content-Type: application/json" \
    --header "Authorization: Bearer $CF_API_KEY"); then
    err "Unable to get DNS Zones"
    errinf "$zones"
    exit 1
  fi

  # Check for domains in Zones and update records as needed
  _retval=0
  for _domain in $DOMAINS; do
    _zone_id=""
    _dsn_record=""
    _dns_ip=""
    
    # Parse Zone data to check if domain exists
    # Get Zone Count
    _zcount=$(out "$zones" | parse_json .result_info.count);
    if [ "$_zcount" = "null" ]; then
      err "Error parsing Zone JSON"
      errinf "$zones"
      _retval=$((_retval+1))
      continue
    fi

    # Loop through Zones to find matching ZONE ID
    while [ "$_zcount" -gt 0 ]; do
      _zname=$(out "$zones" | parse_json .result["$((_zcount-1))"].name)
      if [ "$_domain" = "$_zname" ]; then
        _zone_id=$(out "$zones" | parse_json .result["$((_zcount-1))"].id)
        if [ "$_zone_id" = "null" ]; then
          err "Error parsing Zone JSON"
          errinf "$zones"
          _retval=$((_retval+1))
          continue
        fi
        inf "Zone ID for $_domain: $_zone_id"
        break
      fi
      _zname="" _zone_id=""
      _zcount=$((_zcount-1))
    done

    if [ -z "$_zone_id" ]; then
      err "Unable to get Zone ID for $_domain."
      _retval=$((_retval+1))
      continue
    fi

    # Get DNS record JSON
    if ! _dns_records=$(http_req \
      --request GET \
      --url "$CF_API_URL/zones/$_zone_id/dns_records" \
      --header "Content-Type: application/json" \
      --header "Authorization: Bearer $CF_API_KEY"); then
      err "Unable to get DNS records"
      errinf "$_dns_records"
      _retval=$((_retval+1))
      continue
    fi

    # Parse DNS Records
    # Get record count
    _dcount=$(out "$_dns_records" | parse_json .result_info.count)
    if [ "$_dcount" = "null" ]; then
      err "Error parsing DNS record json."
      errinf "$_dns_records"
      _retval=$((_retval+1))
      continue
    fi

    # Loop through DNS Records to find matching domain
    while [ "$_dcount" -gt 0 ]; do
      _dname=$(out "$_dns_records" | \
        parse_json .result["$((_dcount-1))"].name)
      
      if [ "$_domain" = "$_dname" ]; then
        _dns_id=$(out "$_dns_records" | \
          parse_json .result["$((_dcount-1))"].id)

        if [ "$_dns_id" = "null" ]; then
          err "Error getting DNS ID from DNS Records JSON."
          errinf "$_dns_records"
          _retval=$((_retval+1))
          continue
        fi

        inf "DNS ID for $_domain: $_dns_id"

        _dns_ip=$(out "$_dns_records" | \
          parse_json .result["$((_dcount-1))"].content)

        if [ "$_dns_ip" = "null" ]; then
          err "Error getting DNS IP address from DNS Records JSON."
          errinf "$_dns_records"
          _retval=$((_retval+1))
          continue
        fi

        inf "DNS IP for $_domain: $_dns_ip"
        break

      fi
      _dname="" _dns_id="" _dns_ip=""
      _dcount=$((_dcount-1))
    done

    if [ -z "$_dns_id" ] || [ -z "$_dns_ip" ]; then
      err "Unable to get DNS ID and/or IP address for $_domain."
      _retval=$((_retval+1))
      continue
    fi

    # Check dns ip with public ip
    if [ "$public_ip" = "$_dns_ip" ]; then
      inf "$_domain is already set to $public_ip."
      continue
    fi

    # Update dns ip
    if ! _update_dns_ip=$(http_req \
      --request PATCH \
      --url "$CF_API_URL/zones/$_zone_id/dns_records/$_dns_id" \
      --header "Content-Type: application/json" \
      --header "Authorization: Bearer $CF_API_KEY" \
      --data '{"content": "'"$public_ip"'"}'); then
      err "Unable to patch $_domain with public ip $public_ip."
      errinf "$_update_dns_ip"
      _retval=$((_retval+1))
      continue
    fi
    if [ "$VERBOSE" -gt -1 ]; then
      out "$_domain updated from $_dns_ip to $public_ip"
    fi
  done
  return "$_retval"
}

main "$@"
